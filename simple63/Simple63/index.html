<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Simple63 (simple63.Simple63)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">simple63</a> &#x00BB; Simple63</nav><h1>Module <code>Simple63</code></h1><p>Simple63 is a module for compressing and decompressing sequences of integers along the ideas described in the <a href="https://scholar.google.com/scholar?q=Index+compression+using+64-bit+words+moffat+anh">2010 paper by Anh and Moffat</a>. Like Simple-8b technique described in that paper, Simple63 is a word-bounded, and (as the name suggests) is the result of adapting Simple-8b to work with OCaml's 63-bit integers. While using <code>int64</code> integer types would have been possible, the addtional boxing required to manipulate <code>int64</code>'s make this option unappealing.</p></header><dl><dt class="spec value" id="val-max_value"><a href="#val-max_value" class="anchor"></a><code><span class="keyword">val</span> max_value : int</code></dt><dd><p>The range of integers that can be encoded is <code>0</code> to <code>max_value</code>, where <code>max_value</code> = <code>(1 lsl 59) - 1</code> = <code>576460752303423488</code> ~ <code>5.8e17</code>.</p></dd></dl><dl><dt class="spec exception" id="exception-Invalid"><a href="#exception-Invalid" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Invalid</span> <span class="keyword">of</span> int</code></dt><dd><p>exception <code>Invalid</code> is raised whenever the value of an integer to be encoded falls outside the valid range of such values. See <a href="index.html#val-max_value"><code>max_value</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-encode_to_seq"><a href="#val-encode_to_seq" class="anchor"></a><code><span class="keyword">val</span> encode_to_seq : <span>int Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span>int Stdlib.Seq.t</span></code></dt><dd><p><code>encode_to_seq seq</code> returns an sequence of encoded words (63-bit integers). Example use:</p><pre><code class="ml">let in_lst = [1; 22; 333; 4444] in
let in_seq = List.to_seq in_lst in
let out_seq = encode_to_seq in_seq in

(* confirm that we get out what we've put in: *)
let in_seq' = decode_from_seq out_seq in
let in_lst' = List.of_seq in_seq' in
assert (in_lst = in_lst')</code></pre></dd></dl><dl><dt class="spec value" id="val-decode_from_seq"><a href="#val-decode_from_seq" class="anchor"></a><code><span class="keyword">val</span> decode_from_seq : <span>int Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span>int Stdlib.Seq.t</span></code></dt><dd><p><code>decode_from_seq seq</code> returns a sequence of decoded integers, where <code>seq</code> is a sequence of encoded integers. See <a href="index.html#val-encode_to_seq"><code>encode_to_seq</code></a> for an example.</p></dd></dl><dl><dt class="spec value" id="val-encode_len"><a href="#val-encode_len" class="anchor"></a><code><span class="keyword">val</span> encode_len : <span>int Stdlib.Seq.t</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>encode_len seq</code> returns the number of words into which input sequence <code>seq</code> would be encoded. The quotient of that count and the length of <code>seq</code> is the compression ratio. <code>encode_len</code> merely encodes <code>seq</code> to determine the length of output.</p></dd></dl><dl><dt class="spec type" id="type-iba"><a href="#type-iba" class="anchor"></a><code><span class="keyword">type</span> iba</code><code> = <span><span>(int, Stdlib.Bigarray.int_elt, Stdlib.Bigarray.c_layout)</span> Stdlib.Bigarray.Array1.t</span></code></dt></dl><dl><dt class="spec value" id="val-encode_to_bigarray"><a href="#val-encode_to_bigarray" class="anchor"></a><code><span class="keyword">val</span> encode_to_bigarray : <span>int Stdlib.Seq.t</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-iba">iba</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>encode_to_bigarray seq offset a</code> encodes input sequence <code>seq</code> onto bytearray <code>a</code> starting at offset <code>offset</code></p></dd></dl><dl><dt class="spec value" id="val-decode_from_bigarray"><a href="#val-decode_from_bigarray" class="anchor"></a><code><span class="keyword">val</span> decode_from_bigarray : <span>(int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>n:int</span> <span>&#45;&gt;</span> <span>offset:int</span> <span>&#45;&gt;</span> <a href="index.html#type-iba">iba</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>decode_from_bigarray f ~n ~offset a</code> decodes <code>n</code> integers from bigarray <code>a</code>, starting at array offset <code>offset</code>, and calling function <code>f</code> with each decoded value.</p></dd></dl><dl><dt class="spec value" id="val-encode_to_channel"><a href="#val-encode_to_channel" class="anchor"></a><code><span class="keyword">val</span> encode_to_channel : <span>int Stdlib.Seq.t</span> <span>&#45;&gt;</span> Stdlib.out_channel <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_to_channel seq ouch</code> encodes input sequence <code>seq</code> into output channel <code>ouch</code>.</p></dd></dl><dl><dt class="spec value" id="val-decode_from_channel"><a href="#val-decode_from_channel" class="anchor"></a><code><span class="keyword">val</span> decode_from_channel : <span>(int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.in_channel <span>&#45;&gt;</span> unit</code></dt><dd><p><code>decode_from_channel f inch</code> decodes values from input channel <code>inch</code>, calling function <code>f</code> with each decode value. If <code>End_of_file</code> is encountered prematurely, it is raised.</p></dd></dl></div></body></html>